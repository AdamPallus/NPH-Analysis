#We should assume the normal monkey is making conjugate saccades
#I'll have to update this with the names of other normal monkeys
message(first(z$monkey))
if (first(z$monkey) %in% c('Bee','Ozette')){
z$saccade.type=as.factor('conjugate')
return(z)
}
left.eye.on.start=first(z$pre.l.distance<window.size)
right.eye.on.start=first(z$pre.r.distance<window.size)
left.eye.on.end=first(z$post.l.distance<window.size)
right.eye.on.end=first(z$post.r.distance<window.size)
left.eye.saccade=left.eye.on.start & left.eye.on.end
right.eye.saccade=right.eye.on.start & right.eye.on.end
left.to.right=left.eye.on.start & right.eye.on.end & !right.eye.on.start
right.to.left=right.eye.on.start & left.eye.on.end & !left.eye.on.start
conjugate=left.eye.saccade & right.eye.saccade
if (conjugate){
saccade.type='conjugate'
}else if (left.eye.saccade){
saccade.type='left.only'
} else if (right.eye.saccade) {
saccade.type='right.only'
}else if (left.to.right){
saccade.type='left.to.right'
}else if (right.to.left) {
saccade.type='right.to.left'
}else{
saccade.type='off.target'
}
z$saccade.type=as.factor(saccade.type)
return(z)
}
z %>%
group_by(sacnum) %>%
do(calc.saccade.type(.))->
z
head(z)
z<- filter(t,neuron=='Bee-101')
nrow(z)
z %>%
group_by(neuron) %>%
mutate(lev=parabolicdiff(lep,20),
rev=parabolicdiff(rep,20),
levV=parabolicdiff(lepV,20),
revV=parabolicdiff(repV,20),
sdf=spikedensity(rasters,10),
conj.vertical=(repV+lepV)/2,
verg.velocity=lev-rev,
conj.velocity=sqrt(((rev+lev)/2)^2+((revV+levV)/2)^2),
right.eye.distance=(sqrt((rep-thp)^2+(repV-tvp)^2)),
left.eye.distance=sqrt((lep-thp)^2+(lepV-tvp)^2),
sdf20=lag(sdf,20),
sacnum=markSaccadesDouble(conj.velocity,threshold1=50,threshold2=10,min.dur=20,
driftcorrect = TRUE,markFixations = FALSE))->
z
nrow(z)
unique(z$sacnum)
unique(z$saccade.onset)
head(z)
pre.l.distance=z$left.eye.distance[z$time==(saccade.onset-500)],
pre.r.distance=z$right.eye.distance[z$time==(saccade.onset-500)],
post.l.distance=last(left.eye.distance),
post.r.distance=last(right.eye.distance),
saccade.dur=n(), #was originally a summary
R.H.Amp=last(rep)-first(rep),
L.H.Amp=last(lep)-first(lep),
R.V.Amp=last(repV)-first(repV),
L.V.Amp=last(lepV)-first(lepV),
r.angle=atan2(R.V.Amp,R.H.Amp)*180/pi)->
z
z %>%
filter(!is.na(sacnum)) %>%
group_by(sacnum) %>%
mutate(saccade.onset=first(time)) %>%
filter(saccade.onset>500) %>%
mutate(
pre.l.distance=z$left.eye.distance[z$time==(saccade.onset-500)],
pre.r.distance=z$right.eye.distance[z$time==(saccade.onset-500)],
post.l.distance=last(left.eye.distance),
post.r.distance=last(right.eye.distance),
saccade.dur=n(), #was originally a summary
R.H.Amp=last(rep)-first(rep),
L.H.Amp=last(lep)-first(lep),
R.V.Amp=last(repV)-first(repV),
L.V.Amp=last(lepV)-first(lepV),
r.angle=atan2(R.V.Amp,R.H.Amp)*180/pi)->
z
z<- filter(t,neuron=='Bee-101')
z %>%
group_by(neuron) %>%
mutate(lev=parabolicdiff(lep,20),
rev=parabolicdiff(rep,20),
levV=parabolicdiff(lepV,20),
revV=parabolicdiff(repV,20),
sdf=spikedensity(rasters,10),
conj.vertical=(repV+lepV)/2,
verg.velocity=lev-rev,
conj.velocity=sqrt(((rev+lev)/2)^2+((revV+levV)/2)^2),
right.eye.distance=(sqrt((rep-thp)^2+(repV-tvp)^2)),
left.eye.distance=sqrt((lep-thp)^2+(lepV-tvp)^2),
sdf20=lag(sdf,20),
sacnum=markSaccadesDouble(conj.velocity,threshold1=50,threshold2=10,min.dur=20,
driftcorrect = TRUE,markFixations = FALSE))->
z
z %>%
filter(!is.na(sacnum)) %>%
group_by(sacnum) %>%
mutate(saccade.onset=first(time))->
zz
head(zz)
unique(zz$saccade.onset)
select(zz,saccade.onset,everything())
select(zz,sacnum,saccade.onset,everything())
select(zz,sacnum,time,saccade.onset,everything())
select(t,time,everything())
library(dplyr)
library(ggplot2)
library(data.table)
library(broom)
library(knitr)
library(tidyr)
source('Adamhelperfunctions.R')
preparetoBOOTmarksaccs<- function(z){
calc.saccade.type<- function(z,window.size=5){
#little helper function to assign the correct saccade type
#based on the measurements.
#More robust than using replace since we can do logic
#For the normal monkey, I don't always have the target position information.
#We should assume the normal monkey is making conjugate saccades
#I'll have to update this with the names of other normal monkeys
message(first(z$monkey))
if (first(z$monkey) %in% c('Bee','Ozette')){
z$saccade.type=as.factor('conjugate')
return(z)
}
left.eye.on.start=first(z$pre.l.distance<window.size)
right.eye.on.start=first(z$pre.r.distance<window.size)
left.eye.on.end=first(z$post.l.distance<window.size)
right.eye.on.end=first(z$post.r.distance<window.size)
left.eye.saccade=left.eye.on.start & left.eye.on.end
right.eye.saccade=right.eye.on.start & right.eye.on.end
left.to.right=left.eye.on.start & right.eye.on.end & !right.eye.on.start
right.to.left=right.eye.on.start & left.eye.on.end & !left.eye.on.start
conjugate=left.eye.saccade & right.eye.saccade
if (conjugate){
saccade.type='conjugate'
}else if (left.eye.saccade){
saccade.type='left.only'
} else if (right.eye.saccade) {
saccade.type='right.only'
}else if (left.to.right){
saccade.type='left.to.right'
}else if (right.to.left) {
saccade.type='right.to.left'
}else{
saccade.type='off.target'
}
z$saccade.type=as.factor(saccade.type)
return(z)
}
z %>%
group_by(neuron) %>%
mutate(lev=parabolicdiff(lep,20),
rev=parabolicdiff(rep,20),
levV=parabolicdiff(lepV,20),
revV=parabolicdiff(repV,20),
sdf=spikedensity(rasters,10),
conj.vertical=(repV+lepV)/2,
verg.velocity=lev-rev,
conj.velocity=sqrt(((rev+lev)/2)^2+((revV+levV)/2)^2),
right.eye.distance=(sqrt((rep-thp)^2+(repV-tvp)^2)),
left.eye.distance=sqrt((lep-thp)^2+(lepV-tvp)^2),
sdf20=lag(sdf,20),
sacnum=markSaccadesDouble(conj.velocity,threshold1=50,threshold2=10,min.dur=20,
driftcorrect = TRUE,markFixations = FALSE))->
z
z %>%
filter(!is.na(sacnum)) %>%
group_by(sacnum) %>%
mutate(saccade.onset=first(time)) %>%
filter(saccade.onset>500) %>%
mutate(
pre.l.distance=z$left.eye.distance[z$time==(saccade.onset-500)],
pre.r.distance=z$right.eye.distance[z$time==(saccade.onset-500)],
post.l.distance=last(left.eye.distance),
post.r.distance=last(right.eye.distance),
saccade.dur=n(), #was originally a summary
R.H.Amp=last(rep)-first(rep),
L.H.Amp=last(lep)-first(lep),
R.V.Amp=last(repV)-first(repV),
L.V.Amp=last(lepV)-first(lepV),
r.angle=atan2(R.V.Amp,R.H.Amp)*180/pi)->
z
z %>%
group_by(sacnum) %>%
do(calc.saccade.type(.))->
z
}
bootstrapSaccades<- function(n,z){
samp<-        sample(unique(z$sacnum[z$saccade.type=='left.only']),
length(unique(z$sacnum[z$saccade.type=='left.only'])),replace=TRUE)
samp<- c(samp,sample(unique(z$sacnum[z$saccade.type=='right.only']),
length(unique(z$sacnum[z$saccade.type=='right.only'])),replace=TRUE))
samp<- c(samp,sample(unique(z$sacnum[z$saccade.type=='conjugate']),
length(unique(z$sacnum[z$saccade.type=='conjugate'])),replace=TRUE))
#convert to data.table for faster processing
z <- as.data.table(z)
setkey(z, "sacnum") #like group_by
# create the new data set
z <- z[J(samp), allow.cartesian = TRUE] #replicate data set based on above sample
z %>% #make the model
# filter(abs(verg.velocity)<200) %>%
# do(tidy(lm(sdf20~verg.angle+verg.velocity,data=.))) %>%
do(tidy(lm(sdf20~verg.angle+verg.velocity+conj.vertical,data=.))) %>%
# do(tidy(lm(sdf20~lep+rep+lev+rev,data=.))) %>%
mutate(repN=n)-> #add the number of the bootstrap iteration.
z
}
t %>%
group_by(neuron) %>%
mutate(time=row_number()) %>%
do(preparetoBOOTmarksaccs(.)) ->
preparedtoBOOT
library(dplyr)
library(ggplot2)
library(data.table)
library(broom)
library(knitr)
library(tidyr)
source('Adamhelperfunctions.R')
preparetoBOOTmarksaccs<- function(z){
calc.saccade.type<- function(z,window.size=5){
#little helper function to assign the correct saccade type
#based on the measurements.
#More robust than using replace since we can do logic
#For the normal monkey, I don't always have the target position information.
#We should assume the normal monkey is making conjugate saccades
#I'll have to update this with the names of other normal monkeys
if (first(z$monkey) %in% c('Bee','Ozette')){
z$saccade.type=as.factor('conjugate')
return(z)
}
left.eye.on.start=first(z$pre.l.distance<window.size)
right.eye.on.start=first(z$pre.r.distance<window.size)
left.eye.on.end=first(z$post.l.distance<window.size)
right.eye.on.end=first(z$post.r.distance<window.size)
left.eye.saccade=left.eye.on.start & left.eye.on.end
right.eye.saccade=right.eye.on.start & right.eye.on.end
left.to.right=left.eye.on.start & right.eye.on.end & !right.eye.on.start
right.to.left=right.eye.on.start & left.eye.on.end & !left.eye.on.start
conjugate=left.eye.saccade & right.eye.saccade
if (conjugate){
saccade.type='conjugate'
}else if (left.eye.saccade){
saccade.type='left.only'
} else if (right.eye.saccade) {
saccade.type='right.only'
}else if (left.to.right){
saccade.type='left.to.right'
}else if (right.to.left) {
saccade.type='right.to.left'
}else{
saccade.type='off.target'
}
z$saccade.type=as.factor(saccade.type)
return(z)
}
z %>%
group_by(neuron) %>%
mutate(lev=parabolicdiff(lep,20),
rev=parabolicdiff(rep,20),
levV=parabolicdiff(lepV,20),
revV=parabolicdiff(repV,20),
sdf=spikedensity(rasters,10),
conj.vertical=(repV+lepV)/2,
verg.velocity=lev-rev,
conj.velocity=sqrt(((rev+lev)/2)^2+((revV+levV)/2)^2),
right.eye.distance=(sqrt((rep-thp)^2+(repV-tvp)^2)),
left.eye.distance=sqrt((lep-thp)^2+(lepV-tvp)^2),
sdf20=lag(sdf,20),
sacnum=markSaccadesDouble(conj.velocity,threshold1=50,threshold2=10,min.dur=20,
driftcorrect = TRUE,markFixations = FALSE))->
z
z %>%
filter(!is.na(sacnum)) %>%
group_by(sacnum) %>%
mutate(saccade.onset=first(time)) %>%
filter(saccade.onset>500) %>%
mutate(
pre.l.distance=z$left.eye.distance[z$time==(saccade.onset-500)],
pre.r.distance=z$right.eye.distance[z$time==(saccade.onset-500)],
post.l.distance=last(left.eye.distance),
post.r.distance=last(right.eye.distance),
saccade.dur=n(), #was originally a summary
R.H.Amp=last(rep)-first(rep),
L.H.Amp=last(lep)-first(lep),
R.V.Amp=last(repV)-first(repV),
L.V.Amp=last(lepV)-first(lepV),
r.angle=atan2(R.V.Amp,R.H.Amp)*180/pi)->
z
z %>%
group_by(sacnum) %>%
do(calc.saccade.type(.))->
z
}
bootstrapSaccades<- function(n,z){
samp<-        sample(unique(z$sacnum[z$saccade.type=='left.only']),
length(unique(z$sacnum[z$saccade.type=='left.only'])),replace=TRUE)
samp<- c(samp,sample(unique(z$sacnum[z$saccade.type=='right.only']),
length(unique(z$sacnum[z$saccade.type=='right.only'])),replace=TRUE))
samp<- c(samp,sample(unique(z$sacnum[z$saccade.type=='conjugate']),
length(unique(z$sacnum[z$saccade.type=='conjugate'])),replace=TRUE))
#convert to data.table for faster processing
z <- as.data.table(z)
setkey(z, "sacnum") #like group_by
# create the new data set
z <- z[J(samp), allow.cartesian = TRUE] #replicate data set based on above sample
z %>% #make the model
# filter(abs(verg.velocity)<200) %>%
# do(tidy(lm(sdf20~verg.angle+verg.velocity,data=.))) %>%
do(tidy(lm(sdf20~verg.angle+verg.velocity+conj.vertical,data=.))) %>%
# do(tidy(lm(sdf20~lep+rep+lev+rev,data=.))) %>%
mutate(repN=n)-> #add the number of the bootstrap iteration.
z
}
t %>%
group_by(neuron) %>%
mutate(time=row_number()) %>%
do(preparetoBOOTmarksaccs(.)) ->
preparedtoBOOT
preparedtoBOOT%>%
group_by(neuron) %>%
do(SaccadesBootstrap(.,nreps)) ->
xx
saveRDS(xx,'BootstrapSaccadesBoth3-12-2018.RDS')
preparedtoBOOT%>%
filter(saccade.type == 'left.only') %>%
group_by(neuron) %>%
do(SaccadesBootstrap(.,nreps)) ->
xxLEFT
saveRDS(xx,'BootstrapSaccadesLEFT3-12-2018.RDS')
preparedtoBOOT%>%
filter(saccade.type=='right.only') %>%
group_by(neuron) %>%
do(SaccadesBootstrap(.,nreps)) ->
xxRIGHT
saveRDS(xx,'BootstrapSaccadesRIGHT3-12-2018.RDS')
#
ciplot<-bootstrap.ci(xx)
ggplotly(
ggplot(ciplot,aes(verg.velocity,verg.angle))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5)+
geom_point(size=1,color='hotpink')+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')+
geom_text(aes(label=neuron))
)
ggplotly(
ggplot(ciplot,aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5)+
geom_point(size=1,color='hotpink')+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')
)
ggplotly(
ciplot %>%
filter((verg.velocity.high*verg.velocity.low)>0) %>%
ggplot(aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5)+
geom_point(size=1,color='hotpink')+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')
)
ggplotly(
ciplot %>%
# filter((verg.velocity.high*verg.velocity.low)>0) %>%
ggplot(aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high,color=strabismic),
size=0.5,width=0,alpha=0.2)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high,color=strabismic),
height=0,size=0.5,alpha=0.2)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')
)
ggplotly(
ciplot %>%
filter((verg.velocity.high*verg.velocity.low)>0) %>%
ggplot(aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high,color=strabismic),
size=0.5,width=0,alpha=0.2)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high,color=strabismic),
height=0,size=0.5,alpha=0.2)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')
)
ggplotly(
ciplot %>%
filter((verg.velocity.high*verg.velocity.low)<0) %>%
ggplot(aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high,color=strabismic),
size=0.5,width=0,alpha=0.2)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high,color=strabismic),
height=0,size=0.5,alpha=0.2)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')
)
kable(select(ciplot,neuron,verg.velocity.low,verg.velocity.high))
nrow(xxBOTH)
saveRDS(xxLEFT,'BootstrapSaccadesLEFT3-12-2018.RDS')
saveRDS(xxRIGHT,'BootstrapSaccadesRIGHT3-12-2018.RDS')
xxBOTH<-readRDS('BootstrapSaccadesBoth3-12-2018.RDS')
ciplot<- bootstrap.ci(xxBOTH)
signif.position<- unique(filter(ciplot,(verg.angle.low*verg.angle.high)>0)$neuron)
signif.velocity<-unique(filter(ciplot,(verg.velocity.low*verg.velocity.high)>0)$neuron)
signif.both<- unique(filter(ciplot,(verg.angle.low*verg.angle.high)>0 & (verg.velocity.low*verg.velocity.high)>0)$neuron)
ggplotly(
ggplot(ciplot,aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0,alpha=0.5)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5,alpha=0.5)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')+
ggtitle('All cells')+
annotate('text',-2,5,label=paste0('n = ',nrow(ciplot)))
)
ciplot<- bootstrap.ci(xxBOTH)
signif.position<- unique(filter(ciplot,(verg.angle.low*verg.angle.high)>0)$neuron)
signif.velocity<-unique(filter(ciplot,(verg.velocity.low*verg.velocity.high)>0)$neuron)
signif.both<- unique(filter(ciplot,(verg.angle.low*verg.angle.high)>0 & (verg.velocity.low*verg.velocity.high)>0)$neuron)
ggplotly(
ggplot(ciplot,aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0,alpha=0.5)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5,alpha=0.5)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')+
ggtitle('All cells')+
annotate('text',-2,5,label=paste0('n = ',nrow(ciplot)))
)
ggplotly(
ciplot %>%
filter(neuron %in% signif.both) %>%
ggplot(aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0,alpha=0.5)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5,alpha=0.5)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')+
ggtitle('Cells with significant position and velocity sensitivity')+
annotate('text',-0.3,0,label=paste0('n = ',length(signif.both)))
)
ggplotly(
ciplot %>%
filter(neuron %in% signif.velocity) %>%
ggplot(aes(verg.velocity,verg.angle,label=neuron))+
geom_errorbar(aes(ymin=verg.angle.low,ymax=verg.angle.high),size=0.5,width=0,alpha=0.5)+
geom_errorbarh(aes(xmin=verg.velocity.low,xmax=verg.velocity.high),height=0,size=0.5,alpha=0.5)+
geom_point(size=1,aes(color=strabismic))+
geom_vline(xintercept = 0)+
# coord_fixed()+
# geom_text(aes(label=neuron))+
theme_minimal()+
xlab('Sensitivity to Vergence Velocity')+
ylab('Sensitivity to Vergence Angle')+
ggtitle('Cells with significant position and velocity sensitivity')+
annotate('text',-0.5,-10,label=paste0('n = ',length(signif.velocity)))
)
files <- list.files(path='C:/Users/setup/Desktop/NRTP Vergence/SOA Strabismus/',pattern='*.csv')
write.csv(files,'SOA Strabismus Filenames.csv')
head(xx)
