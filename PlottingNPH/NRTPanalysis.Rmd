---
title: "NRTP Vergence"
author: "Adam"
date: "February 16, 2016"
output: html_document
---
#Introduction
This is an analysis of the activity of individual neurons in the NRTP of monkeys while they make combined saccade vergence movements. 

#Data Processing
* Load .csv files from the appropriate directory. These .csv files were creating using matlab.
* Calclate the lead time for each neuron.
+ shift data from cell and eye coils to align based on lead time
* Identify saccades.

```{r echo=FALSE} 
library(knitr)
opts_chunk$set(echo=FALSE,message=FALSE,warning=FALSE)
```

```{r,message=FALSE}

library(ggplot2)
library(dplyr)
library(knitr)
library(tidyr)
# library(broom)
# library(grid)
# library(relaimpo)
# library(leaps)
#library(data.table)
library(stringr)
```

```{r helperfunctions}

spikedensity<-function (rasters,sd=100) {
  gsize<- sd*10
  g<-dnorm(-gsize:gsize,mean=0,sd=sd)
  sdf<-convolve(rasters,g,type="open")
  sdf<-sdf[gsize:(length(sdf)-(gsize+1))]*1000
  sdf
}

dynamiclead<-function(p,lags=seq(10,300,by=10)) {
  
  rsq<-NULL
  for (i in 1:length(lags)) {
    if (lags[i] > 0){
      p$sdflag<-dplyr::lag(p$sdf,lags[i])
    }
    else{
      p$sdflag<-dplyr::lead(p$sdf,lags[i]*-1)
    }
    
    rsq[i]<- summary(lm(sdflag~rep+lep+repV+lepV,data=p))$r.squared
  }
  #return(rsq)
  return(lags[rsq==max(rsq)])
}

findSaccades<-function(ev){
  
  i<-which(abs(ev)>10) #find all the times when speed > threshold
  sacoff<-which(diff(i)>15) #minimum duration of an accepted saccade
  sacon<-c(1,sacoff+1) #first saccade
  sacoff<-c(sacoff,length(i)) #end of last saccade
  saccade.onset<-i[sacon] #get actual times
  saccade.offset<-i[sacoff] 
  return(data.frame(saccade.onset,saccade.offset))
}

markSaccades<-function(ev,buffer=15){
  #this function finds and marks saccades given a velocity input
  stimes<-findSaccades(ev)
  
  nsaccades=nrow(stimes)
  
  #add 10ms buffer to saccade onset and offset
  #extra code to make sure there is at least that much space in the data

  if(stimes$saccade.onset[1]>buffer+1){
  stimes$saccade.onset=stimes$saccade.onset-buffer
  }else{
    stimes$saccade.onset[2:nsaccades] = stimes$saccade.onset[2:nsaccades]-buffer
    stimes$saccade.onset[1]=1
  }
  if (stimes$saccade.offset[nsaccades]+buffer<length(ev)){
    stimes$saccade.offset=stimes$saccade.offset+buffer
  }else{
    stimes$saccade.offset[1:nsaccades-1]=stimes$saccade.offset[1:nsaccades-1]+buffer
    stimes$saccade.offset[nsaccades]=length(ev)
  }
    
  s<-1:length(ev)*0
  
  for (k in 1:nsaccades){
    s[stimes$saccade.onset[k]:stimes$saccade.offset[k]]<-k
    if(k>1){
      s[stimes$saccade.offset[k-1]:stimes$saccade.onset[k]]<-(k*-1)
    }
  }
  s[1:stimes$saccade.onset[1]]<- -1
  s[stimes$saccade.offset[nrow(stimes)]:length(s)]<- (nrow(stimes)*-1)-1
  return(s)
}

parabolicdiff <- function(pos,n=7){
  q <- sum(2*((1:n)^2))
  convoutput<- convolve(pos,c(-n:-1, 1:n),type="open")
  convoutput<- convoutput[(n*2):(length(pos)-((n*2)+1))]
  vels<- c(array(convoutput[1],dim=n*2),convoutput,array(convoutput[length(convoutput)],dim=n*2))
  vels <- vels/q*1000
}

```

```{r loadfiles,cache=FALSE}
#load all the .csv files in the data folder, then add a column naming the neuron, 
#using the file name as the default name, then put them all together in one long data frame

path<-"C:/Users/setup/Desktop/NRTP Vergence/"

files <- list.files(path=path,pattern='*.csv')
# files<-files[grepl('Patos',files)] # just look at patos files
# files<-files[grepl('Bee',files)] # just look at bee files
t<-data.frame()
nfiles<-length(files)
# nfiles=1
for (i in 1:nfiles) {
  f<-files[i]
  temp <- read.csv(paste(path,f,sep=''))
  names<-str_match(f,"(^[a-zA-Z]+)-([0-9]+)")
  temp$neuron<-names[1]
  temp$monkey<-names[2]
  temp$cellnum<-names[3]
  temp$sdf<-spikedensity(temp$rasters,sd=100)
  leadtime<-dynamiclead(temp)
  temp<-mutate(temp,
               sdflag=lag(sdf,leadtime),
               s=markSaccades((sqrt(rev^2)+sqrt(revV^2))/2),
               time=row_number(),
               verg.angle=rep-lep,
               verg.velocity=parabolicdiff(verg.angle,7),
               isfixation=s<0,
               s=abs(s))
  
  t <-rbind(t,temp)

  }
```

```{r measureMovements}

t %>%
  group_by(neuron,s,isfixation) %>%
  mutate(meanfr=mean(sdflag),
         maxfr=max(sdflag),
         R.Hor=mean(rep),
         R.Ver=mean(repV),
         L.Hor=mean(lep),
         L.Ver=mean(lepV),
         mean.Verg.Angle=mean(verg.angle),
         max.Verg.Vel = max(verg.velocity),
         max.Verg.Ang = max(verg.angle),
         nspikes=sum(rasters),
         dur=n(),
         mean.Spikerate=sum(rasters)/dur*1000,
         R.H.Amp=rep[1]-rep[length(rep)],
         L.H.Amp=lep[1]-lep[length(lep)],
         R.V.Amp=repV[1]-repV[length(repV)],
         L.V.Amp=lepV[1]-lepV[length(lepV)],
         maxamp=max(abs(R.H.Amp),abs(R.V.Amp),abs(L.H.Amp),abs(L.V.Amp)))->
  m

#write.csv(m,"NPHFullData.csv")



t %>%
  group_by(neuron,s) %>%
  summarize(meanfr=mean(sdflag),
            R.Hor=mean(rep),
            R.Ver=mean(repV),
            L.Hor=mean(lep),
            L.Ver=mean(lepV),
            nspikes=sum(rasters),
            
            dur=n(),
            nspk=sum(rasters)/dur*1000)->
  summaryforplot


m %>%
  filter(isfixation=F,dur>150) %>%
  group_by(neuron,s) %>%
  mutate(counter=time-time[1]) ->
mm

```

```{r verg.fixations}
m %>%
  filter(isfixation=T,dur>200) %>%
  summarize(mean.Spikerate=mean.Spikerate[1],
            mean.Verg.Angle=mean.Verg.Angle[1],
            dur=dur[1]) ->
summaryforplot


qplot(mean.Verg.Angle,mean.Spikerate,data=summaryforplot,color=dur)+
  geom_point(size=4)+
  stat_smooth(method='lm')+
  facet_wrap(~neuron)+
  ggtitle('Firing Rate as a function of Vergence Angle during Fixations')
  

# static.model<-lm(mean.Spikerate~mean.Verg.Angle,data=filter(summaryforplot,neuron=="Bee-02"))
# 
# summary(static.model)
# 
# quick.predict <- function(static.model,value) {
#   return(static.model$coefficients[1]+static.model$coefficients[2]*value)
# }
```

```{r change.rate.position}
m %>%
#  filter(isfixation=T) %>%
  group_by(neuron,s) %>%
  summarize(mean.verg=mean.Verg.Angle[1],
            mean.Spikerate=mean.Spikerate[1],
            maxfr=maxfr[n()],
            maxamp=maxamp[n()],
            dur=n()) %>%
  filter(maxamp>3) %>%
  arrange(s) %>%
  mutate(verg.change=mean.verg-lag(mean.verg),
         rate.change=mean.Spikerate-lag(mean.Spikerate)) ->
  mva
```

For each period of fixation, compare the change in vergence and change in firing rate from the previous period of fixation. 

```{r verg.change.vs.rage.change}

qplot(verg.change,rate.change,data=mva)+facet_wrap(~neuron)
```

Plot the peak firing rate detected during the movement. The peak firing rate is calculated using the spike density function, not the interspike interval. This means the peak firing rate is dependent on the width of the gaussian used for the sdf kernel. 

```{r peakfr}
qplot(verg.change,maxfr,data=mva)+facet_wrap(~neuron)
```

Maybe plot some example fixations and saccades after this. Also, we are ready to look at more cells using this analysis. Just sort them, save as .csv and put in the folder listed above. We should also add some statistics to these plots. The example fixations may lead to ideas about how to assess the burst portion better than the simple maximum that we are using currently. Look at the velocity of the saccades too. The burst could be related to the burst. This brings us back to the vergence velocity problem. 