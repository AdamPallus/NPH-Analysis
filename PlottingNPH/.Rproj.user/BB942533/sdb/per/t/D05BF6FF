{
    "contents" : "---\ntitle: \"NRTP Vergence\"\nauthor: \"Adam\"\ndate: \"February 16, 2016\"\noutput: html_document\n---\n#Introduction\nThis is an analysis of the activity of individual neurons in the NRTP of monkeys while they make combined saccade vergence movements. \n\n#Data Processing\n* Load .csv files from the appropriate directory. These .csv files were creating using matlab.\n* Calclate the lead time for each neuron.\n+ shift data from cell and eye coils to align based on lead time\n* Identify saccades.\n\n```{r echo=FALSE} \nlibrary(knitr)\nopts_chunk$set(echo=FALSE,message=FALSE,warning=FALSE)\n```\n\n```{r,message=FALSE}\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(knitr)\nlibrary(tidyr)\n# library(broom)\n# library(grid)\n# library(relaimpo)\n# library(leaps)\n#library(data.table)\nlibrary(stringr)\n```\n\n```{r helperfunctions}\n\nspikedensity<-function (rasters,sd=100) {\n  gsize<- sd*10\n  g<-dnorm(-gsize:gsize,mean=0,sd=sd)\n  sdf<-convolve(rasters,g,type=\"open\")\n  sdf<-sdf[gsize:(length(sdf)-(gsize+1))]*1000\n  sdf\n}\n\ndynamiclead<-function(p,lags=seq(10,300,by=10)) {\n  \n  rsq<-NULL\n  for (i in 1:length(lags)) {\n    if (lags[i] > 0){\n      p$sdflag<-dplyr::lag(p$sdf,lags[i])\n    }\n    else{\n      p$sdflag<-dplyr::lead(p$sdf,lags[i]*-1)\n    }\n    \n    rsq[i]<- summary(lm(sdflag~rep+lep+repV+lepV,data=p))$r.squared\n  }\n  #return(rsq)\n  return(lags[rsq==max(rsq)])\n}\n\nfindSaccades<-function(ev){\n  \n  i<-which(abs(ev)>10) #find all the times when speed > threshold\n  sacoff<-which(diff(i)>15) #minimum duration of an accepted saccade\n  sacon<-c(1,sacoff+1) #first saccade\n  sacoff<-c(sacoff,length(i)) #end of last saccade\n  saccade.onset<-i[sacon] #get actual times\n  saccade.offset<-i[sacoff] \n  return(data.frame(saccade.onset,saccade.offset))\n}\n\nmarkSaccades<-function(ev,buffer=15){\n  #this function finds and marks saccades given a velocity input\n  stimes<-findSaccades(ev)\n  \n  nsaccades=nrow(stimes)\n  \n  #add 10ms buffer to saccade onset and offset\n  #extra code to make sure there is at least that much space in the data\n\n  if(stimes$saccade.onset[1]>buffer+1){\n  stimes$saccade.onset=stimes$saccade.onset-buffer\n  }else{\n    stimes$saccade.onset[2:nsaccades] = stimes$saccade.onset[2:nsaccades]-buffer\n    stimes$saccade.onset[1]=1\n  }\n  if (stimes$saccade.offset[nsaccades]+buffer<length(ev)){\n    stimes$saccade.offset=stimes$saccade.offset+buffer\n  }else{\n    stimes$saccade.offset[1:nsaccades-1]=stimes$saccade.offset[1:nsaccades-1]+buffer\n    stimes$saccade.offset[nsaccades]=length(ev)\n  }\n    \n  s<-1:length(ev)*0\n  \n  for (k in 1:nsaccades){\n    s[stimes$saccade.onset[k]:stimes$saccade.offset[k]]<-k\n    if(k>1){\n      s[stimes$saccade.offset[k-1]:stimes$saccade.onset[k]]<-(k*-1)\n    }\n  }\n  s[1:stimes$saccade.onset[1]]<- -1\n  s[stimes$saccade.offset[nrow(stimes)]:length(s)]<- (nrow(stimes)*-1)-1\n  return(s)\n}\n\nparabolicdiff <- function(pos,n=7){\n  q <- sum(2*((1:n)^2))\n  convoutput<- convolve(pos,c(-n:-1, 1:n),type=\"open\")\n  convoutput<- convoutput[(n*2):(length(pos)-((n*2)+1))]\n  vels<- c(array(convoutput[1],dim=n*2),convoutput,array(convoutput[length(convoutput)],dim=n*2))\n  vels <- vels/q*1000\n}\n\n```\n\n```{r loadfiles,cache=FALSE}\n#load all the .csv files in the data folder, then add a column naming the neuron, \n#using the file name as the default name, then put them all together in one long data frame\n\npath<-\"C:/Users/setup/Desktop/NRTP Vergence/\"\n\nfiles <- list.files(path=path,pattern='*.csv')\n# files<-files[grepl('Patos',files)] # just look at patos files\n# files<-files[grepl('Bee',files)] # just look at bee files\nt<-data.frame()\nnfiles<-length(files)\n# nfiles=1\nfor (i in 1:nfiles) {\n  f<-files[i]\n  temp <- read.csv(paste(path,f,sep=''))\n  names<-str_match(f,\"(^[a-zA-Z]+)-([0-9]+)\")\n  temp$neuron<-names[1]\n  temp$monkey<-names[2]\n  temp$cellnum<-names[3]\n  temp$sdf<-spikedensity(temp$rasters,sd=100)\n  leadtime<-dynamiclead(temp)\n  temp<-mutate(temp,\n               sdflag=lag(sdf,leadtime),\n               s=markSaccades((sqrt(rev^2)+sqrt(revV^2))/2),\n               time=row_number(),\n               verg.angle=rep-lep,\n               verg.velocity=parabolicdiff(verg.angle,7),\n               isfixation=s<0,\n               s=abs(s))\n  \n  t <-rbind(t,temp)\n\n  }\n```\n\n```{r measureMovements}\n\nt %>%\n  group_by(neuron,s,isfixation) %>%\n  mutate(meanfr=mean(sdflag),\n         maxfr=max(sdflag),\n         R.Hor=mean(rep),\n         R.Ver=mean(repV),\n         L.Hor=mean(lep),\n         L.Ver=mean(lepV),\n         mean.Verg.Angle=mean(verg.angle),\n         max.Verg.Vel = max(verg.velocity),\n         max.Verg.Ang = max(verg.angle),\n         nspikes=sum(rasters),\n         dur=n(),\n         mean.Spikerate=sum(rasters)/dur*1000,\n         R.H.Amp=rep[1]-rep[length(rep)],\n         L.H.Amp=lep[1]-lep[length(lep)],\n         R.V.Amp=repV[1]-repV[length(repV)],\n         L.V.Amp=lepV[1]-lepV[length(lepV)],\n         maxamp=max(abs(R.H.Amp),abs(R.V.Amp),abs(L.H.Amp),abs(L.V.Amp)))->\n  m\n\n#write.csv(m,\"NPHFullData.csv\")\n\n\n\nt %>%\n  group_by(neuron,s) %>%\n  summarize(meanfr=mean(sdflag),\n            R.Hor=mean(rep),\n            R.Ver=mean(repV),\n            L.Hor=mean(lep),\n            L.Ver=mean(lepV),\n            nspikes=sum(rasters),\n            \n            dur=n(),\n            nspk=sum(rasters)/dur*1000)->\n  summaryforplot\n\n\nm %>%\n  filter(isfixation=F,dur>150) %>%\n  group_by(neuron,s) %>%\n  mutate(counter=time-time[1]) ->\nmm\n\n```\n\n```{r verg.fixations}\nm %>%\n  filter(isfixation=T,dur>200) %>%\n  summarize(mean.Spikerate=mean.Spikerate[1],\n            mean.Verg.Angle=mean.Verg.Angle[1],\n            dur=dur[1]) ->\nsummaryforplot\n\n\nqplot(mean.Verg.Angle,mean.Spikerate,data=summaryforplot,color=dur)+\n  geom_point(size=4)+\n  stat_smooth(method='lm')+\n  facet_wrap(~neuron)+\n  ggtitle('Firing Rate as a function of Vergence Angle during Fixations')\n  \n\n# static.model<-lm(mean.Spikerate~mean.Verg.Angle,data=filter(summaryforplot,neuron==\"Bee-02\"))\n# \n# summary(static.model)\n# \n# quick.predict <- function(static.model,value) {\n#   return(static.model$coefficients[1]+static.model$coefficients[2]*value)\n# }\n```\n\n```{r change.rate.position}\nm %>%\n#  filter(isfixation=T) %>%\n  group_by(neuron,s) %>%\n  summarize(mean.verg=mean.Verg.Angle[1],\n            mean.Spikerate=mean.Spikerate[1],\n            maxfr=maxfr[n()],\n            maxamp=maxamp[n()],\n            dur=n()) %>%\n  filter(maxamp>3) %>%\n  arrange(s) %>%\n  mutate(verg.change=mean.verg-lag(mean.verg),\n         rate.change=mean.Spikerate-lag(mean.Spikerate)) ->\n  mva\n```\n\nFor each period of fixation, compare the change in vergence and change in firing rate from the previous period of fixation. \n\n```{r verg.change.vs.rage.change}\n\nqplot(verg.change,rate.change,data=mva)+facet_wrap(~neuron)\n```\n\nPlot the peak firing rate detected during the movement. The peak firing rate is calculated using the spike density function, not the interspike interval. This means the peak firing rate is dependent on the width of the gaussian used for the sdf kernel. \n\n```{r peakfr}\nqplot(verg.change,maxfr,data=mva)+facet_wrap(~neuron)\n```\n\nMaybe plot some example fixations and saccades after this. Also, we are ready to look at more cells using this analysis. Just sort them, save as .csv and put in the folder listed above. We should also add some statistics to these plots. The example fixations may lead to ideas about how to assess the burst portion better than the simple maximum that we are using currently. Look at the velocity of the saccades too. The burst could be related to the burst. This brings us back to the vergence velocity problem. ",
    "created" : 1455669325868.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "117|28|150|3|\n",
    "hash" : "1603011613",
    "id" : "D05BF6FF",
    "lastKnownWriteTime" : 1456189289,
    "path" : "~/GitHub/NPH-Analysis/PlottingNPH/NRTPanalysis.Rmd",
    "project_path" : "NRTPanalysis.Rmd",
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_markdown"
}