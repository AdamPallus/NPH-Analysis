{
    "contents" : "---\ntitle: \"BootstrapSaccades\"\nauthor: \"Adam\"\noutput: html_document\n---\n#Introduction\nThis is an analysis of cells believed to be recorded in the NPH of a normal monkey (Bee) and a monkey with exotropia (Patos). The NPH is thought to provide the horizontal integrator for the control of eye movements. Individual neurons in NPH are typically described as either burst-tonic or tonic cells, with activity related to either the position or position and velocity of the eyes. \n\n#Analysis\n*Calclate the lead time for each neuron.\n+shift data from cell and eye coils to align based on lead time\n*Identify saccades.\n+for this analysis, we remove periods of fixation\n*fit and evaluate a linear model: Firing Rate ~ eye position/velocity, horizontal/vertical, left/right (8 terms)\n+Evaluate using Relative Importance\n+Evaluate using BIC and adjusted R^2, using exhaustive search that finds the best model using 1-8 terms\n*Optionally, we can restrict our analysis to just disjunctive saccades. This can help to identify monocular cells, since the parameters during conjugate saccades are typically well correlated.\n\n\n```{r echo=FALSE} \nlibrary(knitr)\nopts_chunk$set(echo=FALSE)\n```\n\n```{r,message=FALSE}\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(knitr)\nlibrary(tidyr)\nlibrary(broom)\nlibrary(grid)\nlibrary(relaimpo)\nlibrary(leaps)\nlibrary(data.table)\n\n```\n\n```{r loadfiles,cache=TRUE}\n#load all the .csv files in the data folder, then add a column naming the neuron, \n#using the file name as the default name, then put them all together in one long data frame\n\n#path<-\"~/GitHub/NPH-Analysis/practicedata/\"\npath<-\"~/GitHub/NPH-Analysis/data/\"\n#path<-\"~/GitHub/NPH-Analysis/testdata/\"\nfiles <- list.files(path=path,pattern='*.csv')\n# files<-files[grepl('Patos',files)] # just look at patos files\n# files<-files[grepl('Bee',files)] # just look at bee files\nt<-data.frame()\nfor (i in 1:length(files)) {\n  temp <- read.csv(paste(path,files[i],sep=''))\n  temp$neuron<-gsub('.csv','',files[i])\n  t <-rbind(t,temp)\n}\n```\n\n```{r leadtime}\ndynamiclead<-function(p,lags=seq(10,300,by=10)) {\n\nrsq<-NULL\nfor (i in 1:length(lags)) {\n  if (lags[i] > 0){\n  p$sdflag<-dplyr::lag(p$sdf,lags[i])\n  }\n  else{\n    p$sdflag<-dplyr::lead(p$sdf,lags[i]*-1)\n  }\n    \n  rsq[i]<- summary(lm(sdflag~rep+lep+repV+lepV,data=p))$r.squared\n}\n#return(rsq)\nreturn(lags[rsq==max(rsq)])\n}\n\nt %>%\n  group_by(neuron) %>%\n  do(leadtime=dynamiclead(.)) %>%\n  mutate(leadtime=as.numeric(leadtime)) ->\n  dl\n  \ndl%>%\n  separate(neuron,c(\"Monkey\",\"cellnum\"),remove =FALSE) %>%\n  mutate(cellnum=as.numeric(cellnum))->\n  dlplot\n\nqplot(cellnum,leadtime/5,data=dlplot,binwidth=10)+facet_grid(Monkey~.)+ylab(\"Lead Time (ms)\")\n\n#At this point I have to switch over to using data.table because dplyr can't handle shifting each group by a different amount. Hopefully this doesn't mess everything else up.\ndl<-setDT(dl)\nt<-setDT(t)\nt<-left_join(t,dl,by=\"neuron\")\n\n#the := operator is actually adding the column shiftsdf to the data table\nt<-t[,sdflag:=shift(sdf,leadtime[1]),by=neuron]\nt<-as.data.frame(t)\n\n```\n\n```{r markSaccades}\n\nfindSaccades<-function(ev){\n  \n  i<-which(abs(ev)>10) #find all the times when speed > threshold\n  sacoff<-which(diff(i)>15) #minimum duration of an accepted saccade\n  sacon<-c(1,sacoff+1) #first saccade\n  sacoff<-c(sacoff,length(i)) #end of last saccade\n  saccade.onset<-i[sacon] #get actual times\n  saccade.offset<-i[sacoff] \n  return(data.frame(saccade.onset,saccade.offset))\n}\n\nmarkSaccades<-function(ev){\n  #this function finds and marks saccades given a velocity input\n  stimes<-findSaccades(ev)\n  \n  nsaccades=nrow(stimes)\n  \n  #add 10ms buffer to saccade onset and offset\n  #extra code to make sure there is at least that much space in the data\n  buffer<- 15\n  if(stimes$saccade.onset[1]>buffer+1){\n  stimes$saccade.onset=stimes$saccade.onset-10\n  }else{\n    stimes$saccade.onset[2:nsaccades] = stimes$saccade.onset[2:nsaccades]-10\n    stimes$saccade.onset[1]=1\n  }\n  if (stimes$saccade.offset[nsaccades]+buffer<length(ev)){\n    stimes$saccade.offset=stimes$saccade.offset+buffer\n  }else{\n    stimes$saccade.offset[1:nsaccades-1]=stimes$saccade.offset[1:nsaccades-1]+buffer\n    stimes$saccade.offset[nsaccades]=length(ev)\n  }\n    \n  s<-1:length(ev)*0\n  \n  for (k in 1:nsaccades){\n    s[stimes$saccade.onset[k]:stimes$saccade.offset[k]]<-k\n    if(k>1){\n      s[stimes$saccade.offset[k-1]:stimes$saccade.onset[k]]<-(k*-1)\n    }\n  }\n  s[1:stimes$saccade.onset[1]]<- -1\n  s[stimes$saccade.offset[nrow(stimes)]:length(s)]<- (nrow(stimes)*-1)\n  return(s)\n}\n```\n\n```{r isolateSaccades,fig.height=46,fig.width=6}\n#use the created functions to mark the saccades\nt %>%\n  mutate(s=markSaccades((sqrt(rev^2)+sqrt(revV^2))/2),time=row_number()) %>%\n  filter(s>0)-> #mark saccades gives saccades positive numbers and everything else negative\n  tt\n```\n\n\n```{r relativeImportance, message=FALSE}\n# library(relaimpo)\n# \n# tt %>%\n#   group_by(neuron) %>%\n#   do(b=calc.relimp(lm(\"sdflag~rep+rev+repV+revV+lep+lev+lepV+levV\",.))) ->\n#   bb\n# for (i in 1:nrow(bb)){\n#   plot(bb$b[[i]],main=bb$neuron[i])\n# }\n```\n\n```{r disjunctiveOnly, cached=TRUE}\n\ntt %>% \n  group_by(neuron,s) %>% \n  summarize(R.H.Amp=rep[1]-rep[length(rep)],\n            L.H.Amp=lep[1]-lep[length(lep)],\n            R.V.Amp=repV[1]-repV[length(repV)],\n            L.V.Amp=lepV[1]-lepV[length(lepV)],\n            maxamp=max(abs(R.H.Amp),abs(R.V.Amp),abs(L.H.Amp),abs(L.V.Amp))) %>%\n  mutate(disjH=sign(R.H.Amp*L.H.Amp)<0,disjV=sign(R.V.Amp*L.V.Amp)<0,disjEither=disjH | disjV) ->\n  amp\ntt <-left_join(tt,amp,by=c('s','neuron'))\n\nminAmp<-5\nnDisjunctive<-nrow(filter(amp,maxamp>minAmp & disjEither))\nnTotal<- nrow(filter(amp,maxamp>minAmp))\n```\n\n\n```{r BICcalc}\n#This function can either just calculate the relative importance or use bootstrapping to find a confidence interval for the relative importance. Bootstrapping obviously takes a long time. Also, it can either fit the model to all of the saccades, or just the disjunctive ones. \ntt %>%\n  filter(maxamp>minAmp,sdflag>10) %>%\n  #filter(maxamp>minAmp & disjEither,sdflag>10) %>%\n  group_by(neuron) %>%\n#    do(b=boot.relimp(lm(\"sdflag~rep+rev+repV+revV+lep+lev+lepV+levV\",.),b=1999),\n    do(b=calc.relimp(lm(\"sdflag~rep+rev+repV+revV+lep+lev+lepV+levV\",.)),\n    bic=regsubsets(sdflag~rep+rev+repV+revV+lep+lev+lepV+levV,.)) ->\n  bb\n\nfor (i in 1:nrow(bb)){\n#  b<-booteval.relimp(bb$b[[i]])\n  b<-bb$b[[i]]\n  plot(b, main=bb$neuron[i])\n  plot(bb$bic[[i]],main=bb$neuron[i])\n  plot(bb$bic[[i]],scale=c('adjr2'),main=bb$neuron[i])\n}\n```\n\nThere were a total of `r nDisjunctive` disjunctive Saccades, out of `r nTotal` total saccades.\n\n```{r bootstrapModel}\n#   bootci <- function(t,n=100,alpha=0.05,formula='sdf~rep+lep'){\n#   t %>%\n#     bootstrap(n) %>%\n#     do(tidy(lm(formula,.))) %>%\n#     group_by(term) %>%\n#     summarize(low=quantile(estimate, alpha / 2),\n#             high=quantile(estimate, 1 - alpha / 2)) ->\n#     ci\n#   return(ci)\n#   }\n# \n#   tt<- ungroup(tt)\n#   n<- unique(tt$neuron)\n#   ci <- data.frame()\n#   f<- \"FRtd~R.P.Horizontal+L.P.Horizontal+R.V.Horizontal+L.V.Horizontal+R.P.Vertical+L.P.Vertical+R.V.Vertical+L.V.Vertical\"\n#   tt %>%\n#     filter(sdflag>10,maxamp>2, disjEither) %>%\n#     rename(R.P.Horizontal=rep,L.P.Horizontal=lep,\n#              R.V.Horizontal=rev,L.V.Horizontal=lev,\n#              R.P.Vertical=repV,L.P.Vertical=lepV,\n#              R.V.Vertical=revV,L.V.Vertical=levV,\n#              FRtd=sdflag) ->\n#     tmodel\n#   for (i in 1:length(n)){\n#     tmodel %>%\n#       filter(neuron==n[i]) %>%\n#       bootci(n=1999,alpha=0.01,formula=f) ->\n#       temp\n#       temp$neuron<-n[i]\n#       ci<-rbind(ci,temp)\n#  }\n```\n \n```{r plotci, fig.width=7,fig.height=30}\n# ci %>%\n#   mutate(m=(low+high)/2) %>%\n#   filter(term != '(Intercept)') ->\n#     pci\n# #   g<-ggplot(pci,aes(factor(term),m)) \n# #   \n# # g+geom_linerange(aes(ymin=low,ymax=high,color=neuron),size=2)+\n# #   facet_grid(neuron~.)+\n# #   geom_hline(x=0)+\n# #   coord_flip()\n# \n# \n# pci %>%\n#   separate(term,c('Direction','PV','HV'),remove=FALSE) %>%\n#   mutate(scale=9*as.numeric(PV=='V')+1,\n#          low=low*scale, high=high*scale,m=m*scale) ->\n#   ppci\n# \n#   g<-ggplot(ppci,aes(factor(term),m)) \n#   \n# g+geom_linerange(aes(ymin=low,ymax=high,color=neuron),size=2)+\n#   facet_grid(neuron~.)+\n#   geom_hline(x=0)+\n#   coord_flip()+\n  # ylab('Coefficient: Velocity scaled by 10')\n```\n\n",
    "created" : 1446584762215.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3117740205",
    "id" : "4ABB7A66",
    "lastKnownWriteTime" : 1447714001,
    "path" : "~/GitHub/NPH-Analysis/PlottingNPH/BootstrapSaccades.Rmd",
    "project_path" : "BootstrapSaccades.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_markdown"
}